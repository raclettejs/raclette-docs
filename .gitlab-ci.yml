stages:
  - build
  - deploy
  - verify

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME-$CI_COMMIT_SHORT_SHA
  LATEST_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME-latest
  SSH_PORT: "22"
  # Required variables (set in GitLab CI/CD settings):
  # SSH_PRIVATE_KEY_B64, SSH_USER, SSH_HOST, DEPLOYMENT_PATH
  # Optional: SSH_PORT (defaults to 22)

.ssh_setup: &ssh_setup
  - apk add --no-cache openssh-client
  - eval $(ssh-agent -s)
  - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
  - mkdir -p ~/.ssh
  - ssh-keyscan -H -p ${SSH_PORT} ${SSH_HOST} >> ~/.ssh/known_hosts

.deploy_script_template: &deploy_script
  stage: deploy
  image: alpine:latest
  before_script:
    - *ssh_setup
  script:
    - |
      # Determine environment-specific settings
      if [ "$CI_COMMIT_BRANCH" = "staging" ]; then
        COMPOSE_FILE="compose.staging.yml"
        PROJECT_NAME="${CI_PROJECT_NAME}-staging"
        BRANCH="staging"
      else
        COMPOSE_FILE="compose.production.yml"
        PROJECT_NAME="${CI_PROJECT_NAME}-production"
        BRANCH="main"
      fi

      PROJECT_PATH="${DEPLOYMENT_PATH}/${PROJECT_NAME}"

      # Create deploy script with proper error handling
      cat > deploy.sh << 'EOF'
      #!/bin/bash
      set -euo pipefail

      PROJECT_PATH="$1"
      IMAGE_TAG="$2"
      COMPOSE_FILE="$3"
      BRANCH="$4"
      REGISTRY_USER="$5"
      REGISTRY_PASSWORD="$6"
      REGISTRY_URL="$7"
      REPO_URL="$8"

      echo "üöÄ Starting deployment of $IMAGE_TAG to: $PROJECT_PATH"
      # Create project directory
      if ! mkdir -p "$PROJECT_PATH"; then
        echo "‚ùå Failed to create project directory: $PROJECT_PATH"
        exit 1
      fi
      cd "$PROJECT_PATH"

      # Update repository - use deploy key instead of job token for security
      echo "üì° Updating repository..."
      if [ -d .git ]; then
        if ! git fetch origin; then
          echo "‚ùå Failed to fetch from origin"
          exit 1
        fi
        if ! git checkout "$BRANCH"; then
          echo "‚ùå Failed to checkout branch: $BRANCH"
          exit 1
        fi
        if ! git reset --hard "origin/$BRANCH"; then
          echo "‚ùå Failed to reset to origin/$BRANCH"
          exit 1
        fi
      else
        if ! git clone -b "$BRANCH" "$REPO_URL" .; then
          echo "‚ùå Failed to clone repository"
          exit 1
        fi
      fi

      # Login to registry
      echo "üîê Logging into container registry..."
      if ! echo "$REGISTRY_PASSWORD" | docker login -u "$REGISTRY_USER" --password-stdin "$REGISTRY_URL"; then
        echo "‚ùå Failed to login to registry"
        exit 1
      fi

      # Pull and deploy
      echo "üì¶ Pulling container images..."
      export IMAGE_TAG="$IMAGE_TAG"
      if ! docker compose -f "$COMPOSE_FILE" pull; then
        echo "‚ùå Failed to pull container images"
        exit 1
      fi

      echo "üîÑ Starting services..."
      if ! docker compose -f "$COMPOSE_FILE" up -d --remove-orphans; then
        echo "‚ùå Failed to start services"
        exit 1
      fi

      echo "‚úÖ Deployment completed successfully"
      docker compose -f "$COMPOSE_FILE" ps
      EOF

      # Use a more secure approach - create the repo URL without exposing tokens
      REPO_URL="https://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"

      # Transfer and execute deploy script
      scp -P ${SSH_PORT} deploy.sh ${SSH_USER}@${SSH_HOST}:/tmp/deploy-${PROJECT_NAME}.sh
      if ! ssh -p ${SSH_PORT} ${SSH_USER}@${SSH_HOST} "chmod +x /tmp/deploy-${PROJECT_NAME}.sh && /tmp/deploy-${PROJECT_NAME}.sh '${PROJECT_PATH}' '${IMAGE_TAG}' '${COMPOSE_FILE}' '${BRANCH}' '${CI_REGISTRY_USER}' '${CI_REGISTRY_PASSWORD}' '${CI_REGISTRY}' '${REPO_URL}'"; then
        echo "‚ùå Deployment failed on remote server"
        exit 1
      fi

      echo "üéâ Deployment pipeline completed successfully"

build:
  stage: build
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - |
      echo "üî® Building Docker image..."
      if ! docker build -t $IMAGE_TAG -t $LATEST_TAG .; then
        echo "‚ùå Docker build failed"
        exit 1
      fi

      echo "üì§ Pushing images to registry..."
      if ! docker push $IMAGE_TAG; then
        echo "‚ùå Failed to push $IMAGE_TAG"
        exit 1
      fi

      if ! docker push $LATEST_TAG; then
        echo "‚ùå Failed to push $LATEST_TAG"
        exit 1
      fi

      echo "‚úÖ Build and push completed successfully"
  rules:
    # Build on MRs targeting main (for validation before merge)
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_DEFAULT_BRANCH
    # Build and push on staging branch
    - if: $CI_COMMIT_BRANCH == "staging"
    # Build and push on main branch
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

deploy_staging:
  <<: *deploy_script
  rules:
    # Auto-deploy when pushing to staging branch
    - if: $CI_COMMIT_BRANCH == "staging" && $CI_PIPELINE_SOURCE != "merge_request_event"

deploy_production:
  <<: *deploy_script
  rules:
    # Auto-deploy when pushing to main branch
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH && $CI_PIPELINE_SOURCE != "merge_request_event"

verify_deployment:
  stage: verify
  image: alpine:latest
  before_script:
    - *ssh_setup
  script:
    - |
      # Determine environment settings
      if [ "$CI_COMMIT_BRANCH" = "staging" ]; then
        PROJECT_NAME="${CI_PROJECT_NAME}-staging"
        COMPOSE_FILE="compose.staging.yml"
      else
        PROJECT_NAME="${CI_PROJECT_NAME}-production" 
        COMPOSE_FILE="compose.production.yml"
      fi

      PROJECT_PATH="${DEPLOYMENT_PATH}/${PROJECT_NAME}"

      echo "üîç Verifying deployment for $PROJECT_NAME..."

      # Create verification script with proper error handling
      cat > verify.sh << 'EOF'
      #!/bin/bash
      set -euo pipefail

      PROJECT_PATH="$1"
      COMPOSE_FILE="$2"
      EXPECTED_IMAGE="$3"

      cd "$PROJECT_PATH"

      echo "=== Verifying deployment ==="
      echo "Expected image: $EXPECTED_IMAGE"

      # Check if containers are running
      echo "üìã Checking container status..."
      RUNNING_CONTAINERS=$(docker compose -f "$COMPOSE_FILE" ps -q)
      if [ -z "$RUNNING_CONTAINERS" ]; then
        echo "‚ùå No containers are running"
        echo "üìù Recent logs:"
        docker compose -f "$COMPOSE_FILE" logs --tail=50
        exit 1
      fi

      # Check container health
      UNHEALTHY=0
      echo "üè• Checking container health..."
      for container in $RUNNING_CONTAINERS; do
        if ! STATUS=$(docker inspect --format='{{.State.Status}}' "$container" 2>/dev/null); then
          echo "‚ùå Failed to inspect container: $container"
          UNHEALTHY=1
          continue
        fi
        
        if ! NAME=$(docker inspect --format='{{.Name}}' "$container" 2>/dev/null | sed 's/^\///'); then
          NAME="unknown-$container"
        fi
        
        if [ "$STATUS" = "running" ]; then
          echo "‚úÖ $NAME: running"
        else
          echo "‚ùå $NAME: $STATUS" 
          UNHEALTHY=1
        fi
      done

      if [ $UNHEALTHY -eq 1 ]; then
        echo "‚ùå Some containers are not healthy"
        echo "üìä Container overview:"
        docker compose -f "$COMPOSE_FILE" ps
        echo "üìù Recent logs:"
        docker compose -f "$COMPOSE_FILE" logs --tail=30
        exit 1
      fi

      echo "üéâ All containers are running successfully!"
      docker compose -f "$COMPOSE_FILE" ps
      EOF

      scp -P ${SSH_PORT} verify.sh ${SSH_USER}@${SSH_HOST}:/tmp/verify-${PROJECT_NAME}.sh
      if ! ssh -p ${SSH_PORT} ${SSH_USER}@${SSH_HOST} "chmod +x /tmp/verify-${PROJECT_NAME}.sh && /tmp/verify-${PROJECT_NAME}.sh '${PROJECT_PATH}' '${COMPOSE_FILE}' '${IMAGE_TAG}'"; then
        echo "‚ùå Deployment verification failed"
        exit 1
      fi

      echo "‚úÖ Deployment verification completed successfully"
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_BRANCH == "staging"
